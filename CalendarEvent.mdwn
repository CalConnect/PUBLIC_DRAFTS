# iCalendar 3 (?!)

Goals:

- Scale from simple to full-featured just by including more properties.
- Use clean JSON key-value structure
- Represent the data currently in iCalendar
- Fix issues we now have with iCalendar
- Can then build multiple APIs on top to get/set, e.g. JMAP or REST-based.

The TC-API Event object has the following properties:

## What

- **title**: `String`
  A short summary of the event. This maps to the SUMMARY property in iCalendar.

General agreement that this should be a simple string property. "Title" is clearer than "summary" to indicate what it is.

- **description**: `String`
  A longer form description of the event. This is plain text, not HTML, but
  a client SHOULD attempt to mark up URLs. This maps to the DESCRIPTION property in iCalendar.

Consistent across all APIs.

## Where

- **locations**: `Location[]`
  An array of locations associated with the event. For locations not marked `isAlternate: true`, the order of the locations in the array indicate the progression during the event. So the first location would be the "start", and the last location the "end".

    A **Location** object has the following properties. All properties are optional, but every Location object MUST have at least one property:

    - **name**: `String`
      The human-readable name of the location.
    - **rel**: `String`
      The relation type of this location to the event. This MUST be either one of the following values, prefixed with `X-`, or registered in a future RFC. Any value the client or server doesn't understand should be treated the same as `unknown`.
      - `start`: The event starts at this location.
      - `end`: The event ends at this location.
    - **timeZone**: `String` (Olsen name)
      A time zone for this location. If omitted, the event time zone MUST be used for this location.
    - **address**: `Address`
      The structured address of this location.

        An **Address** object has the following properties:

        - **street**: `String`
          The street address. This MAY be multiple lines; newlines MUST be preserved.
        - **locality**: `String`
          The city, town, village, post town, or other locality within which the street address may be found.
        - **region**: `String`
          The province, such as a state, county, or canton within which the locality may be found.
        - **postcode**: `String`
          The postal code, post code, ZIP code or other short code associated with the address by the relevant country's postal system.
        - **country**: `String`
          The country name.

    - **coordinates**: `String`
      The `geo:` URI for the location (as per RFC 5870).
    - **uri**: `String`
      A URI that represents how to connect to the event from this location. This may be a telephone number (represented as `tel:+1-555-555-555`) for a teleconference, a web address for online chat, or a custom URI for something like Skype (e.g. `skype:username`).

When mapping from iCalendar, the LOCATION property should become a single location with just a *name* property. If the event has a different end time zone to start time zone, this should be added as a second location with just a *timeZone* property.

## When

- **isAllDay**: `Boolean`
  Is the event an all day event, such as a birthday or public holiday? This corresponds to the type (DATE or DATE-TIME) of the DTSTART property in iCalendar.

- **start**: `LocalDate` e.g. `2015-09-02T00:00:00`
  The date/time the event would start in the event's time zone. This corresponds to the DTSTART property in iCalendar.

- **timeZone**: `String|null`
  The [Olsen Time Zone Database](http://www.iana.org/time-zones) name for the event, or `null` for floating time. This corresponds to the TZID part of the DTSTART property.

- **duration**: `Duration`, e.g. `P2DT3H`
  The duration of the event in absolute time (i.e. ignoring DST shifts, or UTC).

Duration is in a subset of RFC3339/ISO8601 format:
* MUST NOT include decimal (fractional) values
* MUST NOT include year or month values

Durations are in absolute time, i.e. to get the end date in the event time zone, convert start into UTC, then apply the duration, then convert the result into the appropriate time zone.

Restrictions if *isAllDay* is `true`:
* the *start*/*end* properties MUST have a time component of `T00:00:00`
* the *timeZone* property MUST be `null`
* the *duration* MUST only include day and/or week components

### Explanations

#### isAllDay vs. date format:

1. Using a Boolean is easier to understand and is a closer match to what it means (the time span is the same, but it should be displayed differently). Universal agreement on this among current JSON APIs (but name always slightly different!).
2. Single serialisation format for DateTime objects (midnight time part); you don't have to look at an unrelated property to know how to serialise the object.

Advantages of date format:

1. Automatically enforces 00:00:00 time.

#### Local vs. UTC time for date objects:

1. This is how the server has to store it. Time zone definitions can and do change. If you set up an event at 8am next year in Europe/London, it should remain at 8am in Europe/London even if daylight savings is cancelled that year after you create the event. For clients with persistent data stores, this is how they should do it too.
2. Recurrences have to be done in local time, so all other dates on the object (e.g. RDATEs) are in LocalTime, so would be inconsistent to use UTC here.
3. Following on from this, a client can do recurrences without having to support time zones (it can just ignore the time zone data and expand the recurrence to show every event in the event's time zone, which will normally be correct).
4. If the server is doing the recurrences and/or time zone handling then the server would translate the local start/end time into the time zone requested, and not send the time zone fields, so again needs to send local times, not UTC.
5. Easier for humans to read to verify the data is correct (don't have to do date-time conversions in your head!).

Advantages of UTC:

1. Easy to sort events by start time (but still have to resort after translating into viewing time zones because floating time events, so not a big win).
2. Easy to calculate duration if using start/end pair (need to convert local times into UTC before subtracting to get duration in case there's a DST shift).

#### Time zone as a property vs. part of date format:

1. Easier serialisation: single format still for start/end properties.
2. Can be omitted if server is doing time zone translation without changing format of a property.
3. Are semi-independent (often fix time zone after time has been set).

#### Duration vs. End:

Advantages of duration:

1. Should time zone definitions change, it is more likely the duration should remain fixed and the end should shift (e.g. for flights).
2. Recurrences expand the start date and then use duration of first event to determine end date, so it's easier and more consistent if the end date is calculated from duration on normal events too.
3. Guarantees positive duration (required for valid event).
4. Less error prone: if you move the start of a series of events you don't need to make sure to keep the end in sync. You cannot produce a duration that puts the end before the start (negative durations are not allowed).

Advantages of using end date:

1. End is slightly more human-readable (depends on whether the duration is broken up into weeks/days/hours etc. or all in seconds!).
2. Calculating end date 100% accurately requires converting start date to UTC first, then adding duration, then converting back to TZ. Quite complex, however the client will have to be able to do all the elements of this conversion regardless.

Why not allow either?

1. No extra expressivity in choice (or rather, expressivity will be ignored).
2. Complicates all clients and servers that have to deal with them.

#### Time zone format is Olsen name.

1. Much more compact.
2. Almost everyone is using this data.
3. Represents all useful time zones.

## Recurrences

- **recurrenceRule**: `Recurrence|null`
  The recurrence rule for the event, or `null` if it does not recur. This corresponds to the RRULE property in iCalendar.

    A **Recurrence** object is a JSON object mapping of a RECUR value type in iCalendar. A Recurrence object has the following properties:

    - **frequency**: `String`
      This MUST be one of the following values:
      - `"yearly"`
      - `"monthly"`
      - `"weekly"`
      - `"daily"`
      - `"hourly"`
      - `"minutely"`
      - `"secondly"`
      To convert from iCal, simply lower-case the FREQ part.
    - **interval**: `Number` (optional, defaults to `1`)
      The INTERVAL part from iCal. If included, it MUST be an integer `x >= 1`.
    - **rscale**: `String` (optional, defaults to `"gregorian"`)
      The RSCALE part from iCal RSCALE (RFC7529), converted to lower-case.
    - **skip**: `String` (optional, defaults to `"omit"`)
      The SKIP part from iCal RSCALE (RFC7529), converted to lower-case.
    - **firstDayOfWeek**: `String` (optional, defaults to `"monday"`)
      The WKST part from iCal, represented as a lower-case unabbreviated English day of the week. If included, it MUST be one of the following values:

          "monday"|"tuesday"|"wednesday"|"thursday"|"friday"|"saturday"|"sunday"

    - **byDay**: `NDay[]` (optional)
      The BYDAY part from iCal. The array MUST have at least one entry if included.

      An **NDay** object has the following properties:

      - **day**: `String`
        "monday"|"tuesday"|"wednesday"|"thursday"|"friday"|"saturday"|"sunday"
      - **nthOfPeriod**: `Number` (optional)
        If present, rather than representing *every* Friday (for example), it represents only a specific instance within the period (month for monthly recurrences, year for yearly recurrences). Must be a non-zero integer, negative integers means nth-last of period. This is the `"+1"` or `"-3"` etc. prefix from the BYDAY values in iCal.

    - **byDate**: `Number[]` (optional)
      The BYMONTHDAY part from iCal. The array MUST have at least one entry if included.
    - **byMonth**: `String[]` (optional)
      The BYMONTH part from iCal. Each entry is a number, starting from "1" for the first month in the calendar (e.g. "1" means "January" with Gregorian calendar), with an optional "L" suffix for leap months (this MUST be upper-case, e.g. "3L"). The array MUST have at least one entry if included.
    - **byYearDay**: `Number[]` (optional)
      The BYYEARDAY part from iCal. The array MUST have at least one entry if included.
    - **byWeekNo**: `Number[]` (optional)
      The BYWEEKNO part from iCal. The array MUST have at least one entry if included.
    - **byHour**: `Number[]` (optional)
      The BYHOUR part from iCal. The array MUST have at least one entry if included.
    - **byMinute**: `Number[]` (optional)
      The BYMINUTE part from iCal. The array MUST have at least one entry if included.
    - **bySecond**: `Number[]` (optional)
      The BYSECOND part from iCal. The array MUST have at least one entry if included.
    - **bySetPosition**: `Number[]` (optional)
      The BYSETPOS part from iCal. The array MUST have at least one entry if included.
    - **count**: `Number` (optional)
      The COUNT part from iCal. This MUST NOT be included if an *until* property is specified.
    - **until**: `LocalDate` (optional)
      The UNTIL part from iCal. This MUST NOT be included if a *count* property is specified. Note, as in iCal, this date is presumed to be in the timezone specified in *timeZone*. It is not a UTC time.

- **recurrenceOverrides**: `LocalDate[EventPatch[]|null]`
  A combination of RDATE and EXDATE from iCalendar, and event instances with recurrence ids.

    The object is a map of the Recurrence-Id (i.e. the date-time of the start of the occurrence) to either `null`, to indicate the occurrence should be deleted, or an array of patches to apply to the generated Event occurrence object in JSON Patch format ([RFC 6902](https://tools.ietf.org/html/rfc6902)).

    If the recurrence-id does not match an expanded start date from a recurrence rule, it is to be treated as an additional occurrence (like an RDATE from iCalendar). The patch set may often be an empty array in this case.

    By default, an occurrence inherits all properties from the main event except the start time, which is shifted to the new start time, and the end time, which is shifted by the same delta (in absolute time) so the duration remains constant. However, individual properties of the occurrence can be modified by a patch, or multiple patches.

    If patches exist, they MUST all cleanly apply to the generated occurrence object. If a client modifies properties on the master event, it MUST also update the recurrenceOverrides if necessary so all of the patches continue to apply cleanly. The resulting occurrence object after applying the patch MUST conform to standard event constraints (end MUST NOT be before start etc.).

    Every `path` property of every patch MUST NOT be the empty string, and MUST NOT start with one of the following prefixes:

    - /uid
    - /sequence
    - /isAllDay
    - /recurrenceRule
    - /recurrenceOverrides

    The `op` property of the patch MUST be either `"add"` or `"remove"`. Other ops defined in RFC 6902 are not allowed.

    An invalid patch set (for any reason) should not exist, but in practice is likely to be seen in the wild. Calendar systems SHOULD ignore the whole patch set (treat it as though it were an empty array).

### How to (conceptually) expand a recurring event:

1. Apply the recurrence rule to the start date to get a set of start dates for occurrences.
2. Iterate through recurrenceOverrides. For each start date (recurrence id):
   - if it maps to `null`, remove this start date from the set if present.
   - otherwise add it to the set if not present.

You now have the complete list of start dates. The generated event object for each instance is identical to the master event, except:
* The `start` property is set to the occurrence start date.
* The `recurrenceRule` and `recurrenceOverrides` properties are set to `null`/removed.

If the recurrence date maps to an array of patches in the `recurrenceOverrides` property of the master object, you then apply these patches, in order, to the instance object.

### Example event with recurrence and exceptions

    {
      "title": "Team Meeting",
      "isAllDay": false,
      "start": "2016-01-05T10:00:00"
      "timeZone": "Australia/Melbourne",
      "duration": "PT1H"
      "recurrenceRule": {
        "frequency": "weekly"
      },
      "recurrenceOverrides": {
        "2016-01-05T10:00:00": null, // Australia day!
        "2016-02-02T10:00:00": [
          { "op": "add", "path": "/start", "value": "2016-02-02T11:00:00" },
          { "op": "add", "path": "/end", "value": "2016-02-02T12:00:00" },
          { "op": "add", "path": "/description", "value": "Meeting moved 1h later than normal." },
        ]
      }
    }

### Explanations

This representation means all data about the event, and all occurrences, are represented in a single object. This is preferable to the current CalDAV way (where exceptions are completely separate events, but with a recurrence ID + UID to link it to the parent event) as it reduces overall data transfer and makes it easier to get all the information about an event and its occurrences. The patch mechanism for exceptions can also massively reduce data transfer.

In the *Recurrence* object, we chose to use full day names rather than numbers or abbriviated days (e.g. "MO"). Using a string is easier to understand without having to reference the spec, and makes it less likely to get decoding errors (which day is 0/1 etc.? You need to look it up). Using full lower-case names rather than abbreviated is consistent with the naming scheme used in the rest of the spec.

## Scheduling

- **uid**: `String`
  The UID from iCalendar. Used to associate the event as the same across different systems, calendars and views.

- **sequence**: `Number`
  The SEQUENCE field from iCalendar.

- **status**: `String` ("confirmed"|"cancelled"|"tentative")
  The STATUS property from iCalendar. General agreement on this.

- **showAsFree**: `Boolean`
  If true, the even should be ignored when calculating free/busy data for the
  user. This maps to the TRANSP property in iCalendar (`false <=> OPAQUE`, `true <=> TRANSPARENT`).

- **replyTo**: `String|null`
  The email to send scheduling (iMIP) replies to.

- **participants**: `String[Participant]|null`
  A map of calendar-user-id to an object describing their participation in the event. This is a combination of the ORGANIZER and ATTENDEES properties from iCalendar.

    A **Participant** object has the following properties:

    - **isYou**: `Boolean`
      This is `true` if the participant is the logged in user (determining this is not defined and is server dependent).
    - **name**: `String`
      The display name of the calendar user (e.g. "Joe Bloggs").
    - **email**: `String`
      The email address for the calendar user (this is the same as the calendar user id – the key for this object in the participants map – in many systems, but not in all)
    - **kind**: `String` (optional, defaults to "unknown")
      What kind of entity this participant is. This is the CUTYPE parameter in iCalendar. This MUST be either one of the following values, prefixed with `X-`, or registered in a future RFC. Any value the client or server doesn't understand should be treated the same as `unknown`.
      - `user`: a single person
      - `group`: a collection of people invited as a whole
      - `resource`: a non-human resource, e.g. a projector
      - `location`: a physical location involved in the event that needs to be scheduled, e.g. a conference room.
      - `unknown`: no information is available about the kind of this participant.
    - **roles**: `String[]`
      A list of roles that this participant fulfils. At least one value MUST be specified for the participant. The following roles have special meanings, but other values MAY be included too:
      - `owner`: The participant is an organizer of the event, and allowed to make alterations to any part of the event.
      - `attendee`: The participant is an attendee of the event.
      - `chair`: The participant is in charge of the event when it occurs.
    - **scheduleStatus**: `String` (optional, defaults to 'needs-action')
      - `needs-action`: No status yet set by the participant.
      - `accepted`: The participant will attend the event.
      - `declined`: The participant may attend the event.
      - `tentative`: The participant will not attend the event.
    - **schedulePriority**: `String` (optional, defaults to "optional")
      If included, it MUST be one of the following values, prefixed with `X-`, or registered in a future RFC. Any value the client or server doesn't understand should be treated the same as `optional`.
      - `non-participant`: Indicates a participant who is copied for information purposes only.
      - `optional: Indicates a participant whose participation is optional.
      - `required`: Indicates a participant whose participation is required.
    - **scheduleRSVP**: `Boolean` (optional, defaults to `false`)
      If `true`, the organizer is expecting the participant to notify them of their status.
    - **memberOf**: `String[]` (optional)
      A list of group addresses. MUST be omitted if none (rather than an empty array).

- **created**: `UTCDate`
  The CREATED field from iCalendar.

- **updated**: `UTCDate`
  The LAST-MODIFIED field from iCalendar.

## Alerts

- **useDefaultAlerts**: `Boolean`
  If `true`, use the user's default alerts for this event and ignore the
  *alerts* property. Fetching user defaults is dependent on the API from which
  this object is being fetched, and is not defined in this specification.

- **alerts**: `Alert[]|null`
  A list of alerts to display or send the user for this event. This maps to the VALARM property in iCalendar.

    An **Alert** Object has the following properties:

    - **id**: `String`
      An id for matching this alert with a previous version when the event's
      *alerts* property is updated. A UUID is recommended, but any string that
      is unique to the alerts **within this event** is allowed.
    - **relativeTo**: `String` (optional, defaults to `"start"`)
      This specifies whether the alarm will trigger relative to the start or end of the event. The value MUST be either `"start"` or `"end"`.
    - **offset**: `Duration`
      The offset from the start/end of the event to fire the alert. A positive value means an alert *after* the start/end; a negative value indicates an alert *before*. Note, if the event is in floating time (including all-day events), the server SHOULD use the user's default time zone when determining the start time.
    - **action**: `DisplayAction|EmailAction|UnknownAction`
      How to alert the user. A *DisplayAction* means a message (which is service dependent, but SHOULD include the summary and start time of the event) SHOULD be shown to the user on any client connected to this account at the specified time. How this message is formatted (and any sound or other method of drawing the user's attention) is client specific. An *EmailAction* means the server MUST send an email as specified in the object at the specified time.

      Where a **DisplayAction** object has the following properties:

      - **type**: `String`
        The value MUST be `"display"`.
      - **acknowledgedUntil**: `LocalDate|null`
        When the user has permanently dismissed the alert this SHOULD be set to
        the *start* property **of the event, or occurrence if the event is recurring**. Other clients which sync this property can then automatically dismiss or supress duplicate alerts (alerts with the same alert id for an occurrence of this event that starts on or before this date).
      - **snoozedUntil**: `UTCDate|null`
        If the user temporarily dismisses the alert, this is the UTC date-time
        after which it should be reshown. This property MUST be ignored for
        alerts which have been permanently dismissed (see the *acknowledgedUpto*
        property).

      Where an **EmailAction** object has the following properties:

      - **type**: `String`
        The value MUST be `"email"`.
      - **to**: `Emailer[]`
        An array of name/email objects to send the alert to. An **Emailer** object has the following properties:

        - **name**: `String`
          The name of the recipient. If not known, clients SHOULD use the empty string.
        - **email**: `String`
          The email address of the recipient.

      - **subject**: `String` (optional)
        The subject to use for the email. If omitted, this is implementation specific, but the server SHOULD try to choose an appropriate subject (such as "Event Summary: starting in 5 min").
      - **textBody**: `String` (optional)
        The plain-text body to use for the email. If omitted, the body of the email is implementation specific, but the server SHOULD include all pertinent details about the event, such as summary, location and start time.

      An **UnknownAction** object is an object that contains a `type` property whose value is not `"email"` or `"string"`, plus zero or more other properties. This is for compatibility with client extensions and future RFCs. The client or server SHOULD NOT trigger any type of alert for action types they do not understand, but MUST preserve them.

